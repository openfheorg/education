# OpenFHE Examples

The examples are defined [here](https://asecuritysite.com/openfhe/).


## Compiling 

For Windows:

```
g++.exe *.cpp  ..\\..\lib\lib.a -o openfhe_28  -I../../openfhe_main/src/pke/include -I../../openfhe_main/src/binfhe/include -I../../openfhe_main/src/core/include -I../../openfhe_main/src/core -I../../openfhe_main/build/src/core -I../../openfhe_main/src/binfhe -I../../openfhe_main/third-party/cereal/include
```
To use this on Mac OSX, you need to unzip maclib.zip and provide maclib.a in the Lib folder. You can build with:
```
 g++ -std=c++17 *.cpp ../../lib/maclib.a -o openfhe_01 -I../../openfhe_main/src/core/include/utils/prng -I../../openfhe_main/src/pke/include -I../../openfhe_main/src/binfhe/include -I../../openfhe_main/src/core/include -I../../openfhe_main/src/core -I../../openfhe_main/build/src/core -I../../openfhe_main/src/binfhe -I../../openfhe_main/third-party/cereal/include
```

## Homomorphic Encryption with BGV and BFV using OpenFHE using C++

* Adding Two Numbers with Homomomorphic Encryption for BGV and BFV using OpenFHE and C++. [here](https://asecuritysite.com/openfhe/openfhe_02cpp) Adding Two Numbers with Homomomorphic Encryption for BGV and BFV using OpenFHE and C++. The OpenFHE library can support a range of homomorphic encryption methods, and which use Learning With (LWE). In this case, we will homomorphically add two numbers with either BFV or BGV.
* Multiplying Two Numbers with Homomomorphic Encryption for BGV and BFV using OpenFHE and C++. [here](https://asecuritysite.com/openfhe/openfhe_03cpp) Multiplying Two Numbers with Homomomorphic Encryption for BGV and BFV using OpenFHE and C++. The OpenFHE library can support a range of homomorphic encryption methods, and which use Learning With (LWE). In this case, we will homomorphically add two numbers with either BFV or BGV.
* Batch Encoding with BFV/BGV using OpenFHE and C++ (Squaring). Batch Encoding with BFV/BGV using OpenFHE and C++ (Squaring) [here](https://asecuritysite.com/openfhe/openfhe_08cpp). We can convert an array into a plaintext array using a batch mode. Once we have this we can then convert this into a ciphertext array. In this case we will take a sequence of numbers and then convert these to ciphertext value, and then square each value in a batch mode. We can then decrypt and find the square value.
* BFV Inner Product using OpenFHE and C++. BFV Inner Product using OpenFHE and C++. [here](https://asecuritysite.com/openfhe/openfhe_14cpp) The inner product of two vectors of a and b is represented by ⟨a,b⟩. It is the dot product of two vectors, and represented as ⟨a,b⟩=|a|.|y|.cos(θ), and where θ is the angle between the two vectors. In this case, we will use the BFV method to perform an inner product operation with homomorphic encryption.
* BFV Inner Product for Vectors of Varing Size using OpenFHE and C++. BFV Inner Product for Vectors of Varing Size using OpenFHE and C++. The inner product of two vectors of a and b is represented by ⟨a,b⟩. It is the dot product of two vectors, and represented as ⟨a,b⟩=|a|.|y|.cos(θ), and where θ is the angle between the two vectors. In this case, we will use the BFV method to perform an inner product operation with homomorphic encryption. In this case, we will vary the size and scope of the vectors, and compute the inner product.
* Rotation Evaluation with BFV using OpenFHE and C++. Rotation Evaluation with BFV using OpenFHE and C++. Within OpenFHE we can rotate our vectors with a positive shift (to the left) or a negative shift (to the right).
* Matrix Multiplication with Homomomorphic Encryption for BFV using OpenFHE and C++. Matrix Multiplication with Homomomorphic Encryption for BFV using OpenFHE and C++. In this case, we will multiply an encrypted vector (v1) and a matrix (m1) and use homomorphic encryption. It uses an inner product method.
* Vector/Matrix/Matrix Multiplication with Homomomorphic Encryption for BFV using OpenFHE and C++. Vector/Matrix/Matrix Multiplication with Homomomorphic Encryption for BFV using OpenFHE and C++. In this case, we will multiply an encrypted vector (v1) by a matrix (m1) and then by another matrix (m2). The result will be v1.m1.m2. It will homomorphic encryption and BFV.

## Homomorphic Encryption with CKKS using OpenFHE using C++

* Add, Subtract and Multiplying Two Numbers with Homomomorphic Encryption for CKKS using OpenFHE and C++. [here](https://asecuritysite.com/openfhe/openfhe_05cpp) Add, Subtract and Multiplying Two Numbers with Homomomorphic Encryption for CKKS using OpenFHE and C++. The OpenFHE library implements the CKKS homomorphic encryption method. This page will add, subtract and multiply two encrypted floating point values, and uses C++ coding.
* Inner Product with Homomomorphic Encryption for CKKS using OpenFHE and C++. Inner Product with Homomomorphic Encryption for CKKS using OpenFHE and C++. [here](https://asecuritysite.com/openfhe/openfhe_13cpp)The inner product of two vectors of a and b is represented by ⟨a,b⟩.It is the dot product of two vectors, and represented as ⟨a,b⟩=|x|.|y|cosθ, and where θ is the angle between the two vectors.

## DM/FHEW using OpenFHE using C++

* Boolean Circuits with OpenFHE using the FHEW and bootstrapping method (GINX). Boolean Circuits with OpenFHE using the FHEW and bootstrapping method (GINX) with Symmetric Key Encryption. DM (FHEW) [1] uses a LWE (Learning With Error) method that provides fully homomorphic encryption (FHE). It is able to evaluate cipher data applied onto Boolean circuits and uses bootstrapping after each gate evaluation. This allows the evaluation to be conducted in less than 0.1 seconds. The gates implemented are AND, OR, NAND, NOR, and NOT. In homomorphic encryption, the noise in the computation increases as we perform operations. This is typically when we perform a large number of additions. and multiplications will often reduce the amount of noise. A bootstrapping process allows for us to reset the noise and will introduce a delay in the computation. In this case, we will use the Gama-Izabachene-Nguyen-Xie (GINX) [2] bootstrapping method. In this case we will use the Boolean circuit of (b1∧b2)∨(b1∧¬(b2)). This can also be represented as (b1.b2)+(b1.b2¯). We will generate a public key pair, and will encryption with a public key and decrypt with a secret (private) key.
* Boolean Circuits with OpenFHE using the FHEW and bootstrapping method (GINX). Boolean Circuits with OpenFHE using the FHEW and bootstrapping method (GINX) with Public Key Encryption. DM (FHEW) [1] uses a LWE (Learning With Error) method that provides fully homomorphic encryption (FHE). It is able to evaluate cipher data applied onto Boolean circuits and uses bootstrapping after each gate evaluation. This allows the evaluation to be conducted in less than 0.1 seconds. The gates implemented are AND, OR, NAND, NOR, and NOT. In homomorphic encryption, the noise in the computation increases as we perform operations. This is typically when we perform a large number of additions. and multiplications will often reduce the amount of noise. A bootstrapping process allows for us to reset the noise and will introduce a delay in the computation. In this case, we will use the Gama-Izabachene-Nguyen-Xie (GINX) [2] bootstrapping method. In this case we will use the Boolean circuit of (b1∧b2)∨(b1∧¬(b2)) . This can also be represented as (b1.b2)+(b1.b2¯). We will generate a public key pair, and will encryption with a public key and decrypt with a secret (private) key.
* Millionaire's Problem: Simple Homomorphic Cipher for proving if Bob is older than Alice with MD (FHEW). Simple Homomorphic Cipher for proving if Bob is older than Alice with MD (FHEW). This is a simple abstraction of homomorphic cipher for a decision if Bob is older than Alice. In this case we will define Bob and Alice's age will be defined in two bit binary values: 00 (0 - 10 years), 01 (10 - 20 years), 10 (20 - 30 years), and 11 (over 30 years). In this case, we will use the OpenFHE library and use DM (FHEW) [1]. This method uses a LWE (Learning With Error) method that provides fully homomorphic encryption (FHE). It is able to evaluate cipher data applied onto Boolean circuits and uses bootstrapping after each gate evaluation. This allows the evaluation to be conducted in less than 0.1 seconds. The gates implemented are AND, OR, NAND, NOR, and NOT.
* Millionaire's Problem: Simple Homomorphic Cipher for proving if Bob is older than Alice with MD (FHEW) with PKE. Simple Homomorphic Cipher for proving if Bob is older than Alice with MD (FHEW) with PKE. This is a simple abstraction of homomorphic cipher for a decision if Bob is older than Alice. In this case we will define Bob and Alice's age will be defined in two bit binary values: 00 (0 - 10 years), 01 (10 - 20 years), 10 (20 - 30 years), and 11 (over 30 years). In this case, we will use the OpenFHE library and use DM (FHEW) [1]. This method uses a LWE (Learning With Error) method that provides fully homomorphic encryption (FHE). It is able to evaluate cipher data applied onto Boolean circuits and uses bootstrapping after each gate evaluation. This allows the evaluation to be conducted in less than 0.1 seconds. The gates implemented are AND, OR, NAND, NOR, and NOT. We will generate a public key pair, and will encryption with a public key and decrypt with a secret (private) key.
* Homomorphic Cipher - 4-bit adder using MD (FHEW). Homomorphic Cipher - 4-bit adder using MD (FHEW). This is a simple abstraction of Homomorphic Cipher - 4-bit adder. In this case we are adding a and b, where a and b can range from 0 to 15. We will use MD (FHEW) [1] with the OpenFHE library.
* Homomorphic Cipher - 4-bit adder using MD (FHEW) with PKE. Homomorphic Cipher - 4-bit adder using MD (FHEW) with PKE. This is a simple abstraction of Homomorphic Cipher - 4-bit adder. In this case we are adding a and b, where a and b can range from 0 to 15. We will use MD (FHEW) [1] with the OpenFHE library.
* Truth Table with Cipher Circuit with MD (FHEW). Truth Table with Cipher Circuit with MD (FHEW). This is a simple abstraction of logic functions for a Truth Table, and using homomorphic encrytion with the MD (FHEW) method. We will use the Boolean functions that includes (A∧B)∨C((A.B)+C).
* Truth Table with Cipher Circuit with MD (FHEW) with PKE. Truth Table with Cipher Circuit with MD (FHEW) with PKE. This is a simple abstraction of logic functions for a Truth Table, and using homomorphic encrytion with the MD (FHEW) method. We will use the Boolean functions that includes (A∧B)∨C
((A.B)+C).
* Majority and MUX Gates with OpenFHE using the DM (FHEW) and bootstrapping (GINX) using PKE. Majority and MUX Gates with OpenFHE using the DM (FHEW) and bootstrapping (GINX) using PKE. The majority gate will give a 1 output when there are more 1 inputs than zeros. This can be used for consensus mechanisms. with a MUX, we have a switching circuit. For example, we have a three input MUX with a control of c, and then when c is a 0, we will get an ouput of a, and if c is a 1, we will have an output of b. In this case, we will implement homomorphic encryption of the bits using DM (FHEW) [1,2] and bootstrapping (GINX) for a public key encryption scheme, and also for a symmetric key method.
